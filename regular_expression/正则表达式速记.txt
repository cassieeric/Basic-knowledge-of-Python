import re

函数
re.findall(表达式,字符串,标志位=0)                   匹配所有符合表达式的字符,返回列表
re.finditer(表达式,字符串,标志位=0)                  类似于findall,返回一个迭代器,这个迭代器能返回<Match>对象
re.sub(表达式,连接符,字符串,匹配数量=0,标志位=0)       匹配表达式的字符串用连接符替换,匹配数量限制了替换字符的次数,
                                                        0为全部替换,返回原字符串替换后的字符串
re.split(表达式,字符串,匹配数量=0,标志位=0)           分割字符串,返回列表
re.match(表达式,字符串,标志位=0)                     从起始位置匹配,成功返回<Match>对象,失败返回None
re.search(表达式,字符串,标志位=0)                    匹配一次,成功返回<Match>对象,失败返回None
re.compile(表达式,标志位=0)                          获取一个对象,可使用此对象来进行以上多种查找,查找传参方式更改,不用再传表达式
                                                        和标志位,在后面新增两个参数(start,end)开始和结束查找位置
                                                        例:obj.sub('连接符',字符串,匹配数量,开始位置,结束位置)
                                                           obj.findall(字符串,开始位置,结束位置)

函数返回值
findall         如果没有子组,返回包含所有匹配结果的列表,[结果1,结果2]
                如果有1个子组,返回包含所有匹配结果的子组的列表,[子组1,子组1,子组1]
                如果有多个子组,返回[(子组1,子组2),(子组1,子组2)]
findall         返回一个迭代器,这个迭代器能返回<Match>对象
sub             返回原字符串替换后的字符串
split           返回分割后的字符串列表
match,search    成功返回一个<Match>对象,失败返回None
                group():返回匹配结果的完整字符串,也可以使用group(0)
                group(子组1):返回匹配结果的子组1字符串
                group(子组1,子组3,...):返回包含匹配结果的指定子组的元组(子组结果1,子组结果3,...)
                groups():返回一个包含匹配结果的所有子组的元组(子组结果1,子组结果2,...)
                flags:标志位
                pattern:表达式
                string:原始字符串
                pos:查找字符串的开始位置
                endpos:查找字符串的结束位置
                span():返回一个包含匹配结果位置的元组,(开始位置,结束位置)
                start():匹配结果在原始字符串的开始位置
                end():匹配结果在原始字符串的结束位置




主要表达式(会消耗字符)
普通字符     任意字符串,表示要匹配的字符,会消耗字符
.           匹配换行(\n或\r)之外的任意字符
^           匹配^之后的表达式必须在一行字符的开始位置
$           匹配$之前的表达式必须在一行字符的结束位置
\           \之后的字符为转义字符
[字符]       匹配[]中间的任意一个字符,只要[]中有一个字符符合匹配,就匹配成功
[^字符]      匹配除了[]中间的字符,'[^abcde]'能匹配'hello'中的'h','l','l','o'

\d          匹配一个数字字符,等价于[0-9]
\D          匹配一个非数字字符,等价于[^0-9]
\w          匹配包括下划线的任意单词字符,类似但不等价于[a-zA-Z0-9_]
\W          匹配非单词字符,等价于[^a-zA-Z0-9_]
\s          匹配所有看不见的字符,空格,制表符,换页符等等,等价于[ \f\n\r\t\v]
\S          匹配所有能看见的字符,等价于[^ \f\n\r\t\v]
\b          匹配单词的边界
\B          匹配非单词的边界
[\A字符]     匹配起始位置,相当于[]外的^
[字符\Z]     匹配结束为止,相当于[]外的$

\f          换页符
\n          换行符
\r          回车符
\t          制表符
\v          垂直制表符


额外表达式
*           匹配前面的表达式任意次,等价于{0,}
+           匹配前面的表达式出现1次以上,等价于{1,}
?           匹配前面的表达式0次或1次,等价于{0,1}
{n}         n为非负整数,匹配前面的表达式n次
{n,}        n为非负整数,匹配前面的表达式n次以上
{n,m}       n,m为非负整数,n<=m,匹配前面的表达式n至m次


非贪婪模式
?           非贪婪模式,尽可能的少匹配次数,如'0000'字符串使用'0+?',得到结果[0,0,0,0]
            贪婪模式:'ab.*ab'匹配'ab123abxxxxxab12ab'得到['ab123abxxxxxab12ab']
            非贪婪模式:'ab.*?ab'匹配'ab123abxxxxxab12ab'得到['ab123ab','ab12ab']


高阶表达式
(?P<变量名>值)      将一个值赋给变量
(?P=变量名)         调用变量
l|r                匹配左边或者右边的字符,单独使用会消耗字符
(?:表达式)          非获取匹配,表示括号内容不作为子组,会消耗字符串,如x1|x2等价于x(?:1|2)
以下五种表达式为非获取匹配,表示括号内容不作为子组,并且不消耗字符
(?=表达式)          正向预查,类似于[]筛选,但是正向预查可以包含多个字符如win(?=98|2000|NT),可以匹配win2000中的win
(?!表达式)          正向否定预查,类似于[^]筛选,但是可以包含多个字符如win(?!98|2000|NT),不能匹配win2000但是可以匹配win95中的win
(?<=表达式)         反向预查,类似于正向预查,写法:(?<=98|20|NT)win,要求表达式长度必须相同(?<=98|2000|NT)win会报错
(?<!表达式)         反向否定预查,类似于正向否定预查,写法:(?<!98|20|NT)win,要求表达式长度必须相同(?<!98|2000|NT)win会报错



标志位
re.I        使匹配对大小写不敏感
re.L        做本地化识别（locale-aware）匹配
re.M        多行匹配，影响 ^ 和 $
re.S        使 . 匹配包括换行在内的所有字符
re.U        根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.
re.X        该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解

